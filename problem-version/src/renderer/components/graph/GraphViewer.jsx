/**
 * @brief React Flow Í∏∞Î∞ò Í∑∏ÎûòÌîÑ ÏãúÍ∞ÅÌôî Ïª¥Ìè¨ÎÑåÌä∏
 * @details CodeVisorÏùò ÌïµÏã¨ ÏãúÍ∞ÅÌôî Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
 * @author CodeVisor Team
 * @date 2025-06-20
 */

import React, { useCallback, useMemo, useState, useEffect } from 'react';
import {
  ReactFlow,
  MiniMap,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  addEdge,
  Panel,
  useReactFlow,
  ReactFlowProvider,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import CustomNode from './CustomNode';
import GraphControls from './GraphControls';
import GraphMinimap from './GraphMinimap';

/**
 * @brief ÎÇ¥Î∂Ä Í∑∏ÎûòÌîÑ Ïª¥Ìè¨ÎÑåÌä∏ (ReactFlow ÌõÖ ÏÇ¨Ïö©ÏùÑ ÏúÑÌï¥ Î∂ÑÎ¶¨)
 */
const GraphViewerInner = ({
  initialNodes = [],
  initialEdges = [],
  onNodeClick,
  onNodeSelect,
  filterOptions = {},
  onFilterChange,
  onLayoutChange,
  isLoading = false,
  noDataComponent = null,
}) => {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
  const [selectedNodes, setSelectedNodes] = useState(new Set());
  const [isInitialized, setIsInitialized] = useState(false);
  
  // ReactFlow Ïù∏Ïä§ÌÑ¥Ïä§ ÏÇ¨Ïö©
  const reactFlowInstance = useReactFlow();

  // Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
  const handleLayoutChange = useCallback(async (layoutType) => {
    console.log('üîÑ GraphViewer: Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω ÏöîÏ≤≠:', layoutType, 'ÌòÑÏû¨ ÎÖ∏Îìú Ïàò:', nodes.length);
    
    // Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïùò Ìï∏Îì§Îü¨Í∞Ä ÏûàÏúºÎ©¥ Í∑∏Í≤ÉÏùÑ ÏÇ¨Ïö© (MainPageÏóêÏÑú Ï†ÑÎã¨Îêú Í≤É)
    if (onLayoutChange) {
      console.log('üìû GraphViewer: Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏ Î†àÏù¥ÏïÑÏõÉ Ìï∏Îì§Îü¨ Ìò∏Ï∂ú');
      onLayoutChange(layoutType);
      return;
    }
    
    // Î∞±ÏóÖÏö© ÏûêÏ≤¥ Ï≤òÎ¶¨ (Î∂ÄÎ™® Ìï∏Îì§Îü¨Í∞Ä ÏóÜÎäî Í≤ΩÏö∞)
    if (nodes.length === 0) {
      console.log('‚ö†Ô∏è GraphViewer: ÎÖ∏ÎìúÍ∞Ä ÏóÜÏñ¥ Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω Í±¥ÎÑàÎúÄ');
      return;
    }
    
    try {
      // ÌòÑÏû¨ Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞Î•º Ï§ÄÎπÑ
      const graphData = {
        nodes: nodes.map(node => ({
          id: node.id,
          name: node.data?.label || node.id,
          filePath: node.data?.filePath || '',
          type: node.data?.nodeType || 'module',
          exports: node.data?.exports || [],
          imports: node.data?.imports || [],
          functions: node.data?.functions || [],
          components: node.data?.components || [],
          metadata: node.data?.metadata || {}
        })),
        edges: edges.map(edge => ({
          id: edge.id,
          source: edge.source,
          target: edge.target,
          type: edge.data?.edgeType || 'import',
          imports: edge.data?.imports || []
        }))
      };
      
      console.log('üìä GraphViewer: Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑÎê®:', graphData.nodes.length, 'ÎÖ∏Îìú');
      
      // ÏßÅÏ†ë Electron API Ìò∏Ï∂ú
      if (window.electronAPI && window.electronAPI.graph) {
        console.log('üîå GraphViewer: Electron API Ìò∏Ï∂ú ÏãúÏûë');
        const layoutResult = await window.electronAPI.graph.generateLayout(
          { dependencyGraph: graphData },
          layoutType
        );
        
        console.log('üì¶ GraphViewer: API ÏùëÎãµ:', layoutResult);
        
        if (layoutResult.success && layoutResult.nodes) {
          console.log('‚úÖ GraphViewer: Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω ÏÑ±Í≥µ, ÎÖ∏Îìú ÏóÖÎç∞Ïù¥Ìä∏:', layoutResult.nodes.length);
          console.log('üéØ GraphViewer: Ï≤´ Î≤àÏß∏ ÎÖ∏Îìú ÏÉà ÏúÑÏπò:', layoutResult.nodes[0]?.position);
          setNodes(layoutResult.nodes);
          setEdges(layoutResult.edges || []);
          
          // Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω ÌõÑ React Flow Ïû¨Ï¥àÍ∏∞Ìôî
          setTimeout(() => {
            console.log('üîÑ Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω ÌõÑ React Flow Ïû¨Ï¥àÍ∏∞Ìôî');
            setReactFlowKey(prev => prev + 1);
            
            setTimeout(() => {
              reactFlowInstance.fitView({ duration: 800, padding: 0.1 });
            }, 100);
          }, 100);
        } else {
          console.error('‚ùå GraphViewer: Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω Ïã§Ìå®:', layoutResult.error);
        }
      } else {
        console.error('‚ùå GraphViewer: Electron APIÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§');
        console.error('   window.electronAPI Ï°¥Ïû¨:', !!window.electronAPI);
        console.error('   window.electronAPI.graph Ï°¥Ïû¨:', !!window.electronAPI?.graph);
      }
    } catch (error) {
      console.error('GraphViewer: Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω Ïã§Ìå®:', error);
    }
  }, [nodes, edges, setNodes, setEdges, reactFlowInstance, onLayoutChange]);

  // Ïª§Ïä§ÌÖÄ ÎÖ∏Îìú ÌÉÄÏûÖ Ï†ïÏùò
  const nodeTypes = useMemo(
    () => ({
      custom: CustomNode,
    }),
    []
  );

  // ÎÖ∏Îìú Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ - React Flow key Ïû¨ÏÑ§Ï†ïÏúºÎ°ú ÏôÑÏ†Ñ Ïû¨Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    console.log('üîÑ GraphViewer: initialNodes Î≥ÄÍ≤ΩÎê®:', initialNodes.length, 'Í∞ú ÎÖ∏Îìú');
    
    if (initialNodes.length > 0) {
      // Ï≤´ Î≤àÏß∏ ÎÖ∏Îìú ÏúÑÏπò ÌôïÏù∏
      console.log('üìç GraphViewer: Ï≤´ Î≤àÏß∏ ÎÖ∏Îìú ÏúÑÏπò:', initialNodes[0].position);
      
      // Ï¶âÏãú ÎÖ∏Îìú ÏÑ§Ï†ï (Îçî Ïù¥ÏÉÅ ÏßÄÏó∞ ÏóÜÏùå)
      console.log('üéØ GraphViewer: Ï¶âÏãú ÎÖ∏Îìú ÏÑ§Ï†ï');
      setNodes(initialNodes);
      setIsInitialized(true);
    } else {
      setNodes([]);
      setIsInitialized(false);
    }
  }, [initialNodes, setNodes]);

  // Ïó£ÏßÄ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ 
  useEffect(() => {
    console.log('üîÑ GraphViewer: initialEdges Î≥ÄÍ≤ΩÎê®:', initialEdges.length, 'Í∞ú Ïó£ÏßÄ');
    setEdges(initialEdges);
  }, [initialEdges, setEdges]);

  // React Flow ÏôÑÏ†Ñ Ïû¨Ï¥àÍ∏∞ÌôîÎ•º ÏúÑÌïú ÌÇ§ ÏÉÅÌÉú
  const [reactFlowKey, setReactFlowKey] = useState(0);

  // Ï¥àÍ∏∞Ìôî ÌõÑ ÏûêÎèô Î∑∞ ÎßûÏ∂§
  useEffect(() => {
    if (isInitialized && nodes.length > 0 && reactFlowInstance) {
      console.log('üéØ GraphViewer: Ï¥àÍ∏∞Ìôî ÏôÑÎ£å, ÎÖ∏Îìú ÏúÑÏπò ÌôïÏù∏');
      
      // ÌòÑÏû¨ ÎÖ∏ÎìúÎì§Ïùò ÏúÑÏπò Î°úÍπÖ
      nodes.forEach(node => {
        console.log(`üìç ÎÖ∏Îìú ${node.id}: position(${node.position.x}, ${node.position.y})`);
      });
      
      // React Flow ÏôÑÏ†Ñ Ïû¨Ï¥àÍ∏∞ÌôîÎ°ú ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅ Ìï¥Í≤∞
      console.log('üîÑ React Flow ÏôÑÏ†Ñ Ïû¨Ï¥àÍ∏∞Ìôî');
      setReactFlowKey(prev => prev + 1);
      
      // ÏûêÎèô Î∑∞ ÎßûÏ∂§
      setTimeout(() => {
        reactFlowInstance.fitView({ duration: 800, padding: 0.1 });
        console.log('üìå ÏûêÎèô Î∑∞Ìè¨Ìä∏ ÎßûÏ∂§ ÏôÑÎ£å');
      }, 300);
    }
  }, [isInitialized, nodes.length, reactFlowInstance]);

  // ÌïÑÌÑ∞ Ï†ÅÏö©
  const filteredNodes = useMemo(() => {
    if (!filterOptions || Object.keys(filterOptions).length === 0) {
      return nodes;
    }

    return nodes.filter(node => {
      // ÎÖ∏Îìú ÌÉÄÏûÖ ÌïÑÌÑ∞
      if (filterOptions.nodeTypes && filterOptions.nodeTypes.length > 0) {
        if (!filterOptions.nodeTypes.includes(node.data.nodeType)) {
          return false;
        }
      }

      // Í≤ÄÏÉâÏñ¥ ÌïÑÌÑ∞
      if (filterOptions.searchTerm) {
        const searchTerm = filterOptions.searchTerm.toLowerCase();
        const nodeName = node.data.label.toLowerCase();
        const filePath = node.data.filePath?.toLowerCase() || '';
        
        if (!nodeName.includes(searchTerm) && !filePath.includes(searchTerm)) {
          return false;
        }
      }

      // Î≥µÏû°ÎèÑ ÌïÑÌÑ∞
      if (filterOptions.minComplexity !== undefined || filterOptions.maxComplexity !== undefined) {
        const complexity = node.data.metadata?.complexity || 0;
        
        if (filterOptions.minComplexity !== undefined && complexity < filterOptions.minComplexity) {
          return false;
        }
        
        if (filterOptions.maxComplexity !== undefined && complexity > filterOptions.maxComplexity) {
          return false;
        }
      }

      return true;
    });
  }, [nodes, filterOptions]);

  // ÌïÑÌÑ∞Îêú ÎÖ∏ÎìúÏóê Ìï¥ÎãπÌïòÎäî Ïó£ÏßÄÎßå ÌëúÏãú
  const filteredEdges = useMemo(() => {
    const filteredNodeIds = new Set(filteredNodes.map(node => node.id));
    return edges.filter(edge => 
      filteredNodeIds.has(edge.source) && filteredNodeIds.has(edge.target)
    );
  }, [edges, filteredNodes]);

  // ÎÖ∏Îìú Ïó∞Í≤∞ Ìï∏Îì§Îü¨
  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  // ÎÖ∏Îìú ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handleNodeClick = useCallback((event, node) => {
    // Îã§Ï§ë ÏÑ†ÌÉù Ï≤òÎ¶¨
    if (event.ctrlKey || event.metaKey) {
      setSelectedNodes(prev => {
        const newSet = new Set(prev);
        if (newSet.has(node.id)) {
          newSet.delete(node.id);
        } else {
          newSet.add(node.id);
        }
        return newSet;
      });
    } else {
      setSelectedNodes(new Set([node.id]));
    }

    // Ïô∏Î∂Ä Ìï∏Îì§Îü¨ Ìò∏Ï∂ú
    if (onNodeClick) {
      onNodeClick(node, Array.from(selectedNodes));
    }
  }, [onNodeClick, selectedNodes]);

  // ÎÖ∏Îìú ÏÑ†ÌÉù Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
  const handleSelectionChange = useCallback((elements) => {
    const selectedNodeIds = elements.nodes?.map(node => node.id) || [];
    setSelectedNodes(new Set(selectedNodeIds));
    
    if (onNodeSelect) {
      onNodeSelect(selectedNodeIds);
    }
  }, [onNodeSelect]);

  // Í∑∏ÎûòÌîÑ Ïª®Ìä∏Î°§ Ìï∏Îì§Îü¨Îì§
  const handleZoomIn = useCallback(() => {
    const currentZoom = reactFlowInstance.getZoom();
    reactFlowInstance.setViewport({ zoom: currentZoom * 1.5 });
  }, [reactFlowInstance]);

  const handleZoomOut = useCallback(() => {
    const currentZoom = reactFlowInstance.getZoom();
    reactFlowInstance.setViewport({ zoom: currentZoom * 0.7 });
  }, [reactFlowInstance]);

  const handleFitView = useCallback(() => {
    reactFlowInstance.fitView({ duration: 800, padding: 0.4, maxZoom: 0.6 });
  }, [reactFlowInstance]);

  const handleCenterNode = useCallback((nodeId) => {
    const node = nodes.find(n => n.id === nodeId);
    if (node && node.position) {
      reactFlowInstance.setCenter(node.position.x, node.position.y, { 
        duration: 800, 
        zoom: 1.5 
      });
    }
  }, [nodes, reactFlowInstance]);

  // ÎÖ∏Îìú Ïä§ÌÉÄÏùº ÏóÖÎç∞Ïù¥Ìä∏ (ÏÑ†ÌÉù ÏÉÅÌÉú Î∞òÏòÅ)
  const styledNodes = useMemo(() => {
    // ÎÖ∏Îìú ÏúÑÏπò Ï§ëÎ≥µ ÌôïÏù∏
    const positionMap = new Map();
    filteredNodes.forEach(node => {
      const key = `${node.position?.x},${node.position?.y}`;
      if (!positionMap.has(key)) {
        positionMap.set(key, []);
      }
      positionMap.get(key).push(node.id);
    });
    
    // Ï§ëÎ≥µ ÏúÑÏπò Í≤ΩÍ≥†
    positionMap.forEach((nodeIds, position) => {
      if (nodeIds.length > 1) {
        console.warn(`‚ö†Ô∏è ÎÖ∏Îìú ÏúÑÏπò Ï§ëÎ≥µ Î∞úÍ≤¨! ÏúÑÏπò ${position}Ïóê ${nodeIds.length}Í∞ú ÎÖ∏Îìú:`, nodeIds);
      }
    });
    
    return filteredNodes.map(node => ({
      ...node,
      selected: selectedNodes.has(node.id),
      draggable: true,
      style: {
        ...node.style,
        opacity: selectedNodes.size === 0 || selectedNodes.has(node.id) ? 1 : 0.3,
        transform: selectedNodes.has(node.id) ? 'scale(1.1)' : 'scale(1)',
        transition: 'all 0.2s ease-in-out',
      }
    }));
  }, [filteredNodes, selectedNodes]);

  // Ïó£ÏßÄ Ïä§ÌÉÄÏùº ÏóÖÎç∞Ïù¥Ìä∏ (ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÏôÄ Ïó∞Í≤∞Îêú Ïó£ÏßÄ Í∞ïÏ°∞)
  const styledEdges = useMemo(() => {
    return filteredEdges.map(edge => {
      const isConnectedToSelected = selectedNodes.has(edge.source) || selectedNodes.has(edge.target);
      
      return {
        ...edge,
        style: {
          ...edge.style,
          opacity: selectedNodes.size === 0 || isConnectedToSelected ? 1 : 0.2,
          strokeWidth: isConnectedToSelected ? 3 : edge.style?.strokeWidth || 2,
        }
      };
    });
  }, [filteredEdges, selectedNodes]);

  // Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú React Flow ÏóÖÎç∞Ïù¥Ìä∏ - Î™®Îì† Ï°∞Í±¥Î∂Ä return Ïù¥Ï†ÑÏóê ÏúÑÏπò
  useEffect(() => {
    const handleResize = () => {
      if (reactFlowInstance) {
        reactFlowInstance.fitView({ duration: 300 });
      }
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [reactFlowInstance]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500 mx-auto mb-4"></div>
          <p className="text-gray-600">Í∑∏ÎûòÌîÑÎ•º ÏÉùÏÑ±ÌïòÍ≥† ÏûàÏäµÎãàÎã§...</p>
        </div>
      </div>
    );
  }

  console.log('GraphViewer Î†åÎçîÎßÅ - nodes:', nodes.length, ', edges:', edges.length);
  console.log('GraphViewer Î†åÎçîÎßÅ - filteredNodes:', filteredNodes.length, ', styledNodes:', styledNodes.length);
  if (styledNodes.length > 0) {
    console.log('GraphViewer: Î†åÎçîÎßÅÌï† Ï≤´ Î≤àÏß∏ ÎÖ∏Îìú:', JSON.stringify(styledNodes[0], null, 2));
  }
  
  // ÎÖ∏ÎìúÍ∞Ä ÏóÜÍ≥† noDataComponentÍ∞Ä Ï†úÍ≥µÎêú Í≤ΩÏö∞
  if (nodes.length === 0 && noDataComponent && !isLoading) {
    return noDataComponent;
  }
  
  return (
    <div className="graph-viewer" style={{ width: '100%', height: '100%', minHeight: '500px', position: 'relative' }}>
      <ReactFlow
        key={reactFlowKey}
        nodes={styledNodes}
        edges={styledEdges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onNodeClick={handleNodeClick}
        onSelectionChange={handleSelectionChange}
        onNodeDrag={(event, node) => {
          console.log('ÎÖ∏Îìú ÎìúÎûòÍ∑∏ Ï§ë:', node.id, node.position);
        }}
        onNodeDragStop={(event, node) => {
          console.log('ÎÖ∏Îìú ÎìúÎûòÍ∑∏ ÏôÑÎ£å:', node.id, node.position);
          
          // React Flow ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (transformÏùÄ ÏûêÎèôÏúºÎ°ú Í≥ÑÏÇ∞ÎêòÎèÑÎ°ù)
          setNodes(prevNodes => 
            prevNodes.map(n => 
              n.id === node.id ? { ...n, position: node.position } : n
            )
          );
        }}
        nodeTypes={nodeTypes}
        nodesDraggable={true}
        nodesConnectable={true}
        elementsSelectable={true}
        panOnDrag={[1, 2]}
        panOnScroll={true}
        selectionOnDrag={false}
        nodeDragThreshold={1}
        fitView={true}
        fitViewOptions={{ duration: 200, padding: 0.1 }}
        defaultViewport={{ x: 0, y: 0, zoom: 0.8 }}
        minZoom={0.1}
        maxZoom={2}
        deleteKeyCode={['Backspace', 'Delete']}
        selectionKeyCode={['Meta', 'Ctrl']}
        multiSelectionKeyCode={['Meta', 'Ctrl']}
        className="bg-gray-50"
        proOptions={{ hideAttribution: true }}
        onInit={(instance) => {
          console.log('ReactFlow Ï¥àÍ∏∞ÌôîÎê®');
          console.log('ÌòÑÏû¨ ÎÖ∏Îìú Ïàò:', instance.getNodes().length);
        }}
      >
        {/* Î∞∞Í≤Ω Ìå®ÌÑ¥ */}
        <Background 
          variant="dots" 
          gap={20} 
          size={1} 
          color="#e5e7eb"
        />

        {/* ÎØ∏ÎãàÎßµ */}
        <GraphMinimap 
          nodes={filteredNodes}
          selectedNodes={selectedNodes}
        />

        {/* Í∏∞Î≥∏ Ïª®Ìä∏Î°§ */}
        <Controls 
          showInteractive={false}
          className="bg-white shadow-lg border border-gray-200"
        />

        {/* Ïª§Ïä§ÌÖÄ Ïª®Ìä∏Î°§ Ìå®ÎÑê */}
        <Panel position="top-left" className="m-4">
          <GraphControls
            onZoomIn={handleZoomIn}
            onZoomOut={handleZoomOut}
            onFitView={handleFitView}
            onCenterNode={handleCenterNode}
            selectedNodes={Array.from(selectedNodes)}
            totalNodes={filteredNodes.length}
            totalEdges={filteredEdges.length}
            onLayoutChange={handleLayoutChange}
            onFilterChange={onFilterChange}
            filterOptions={filterOptions}
          />
        </Panel>

        {/* ÌÜµÍ≥Ñ Ï†ïÎ≥¥ Ìå®ÎÑê */}
        <Panel position="bottom-left" className="m-4">
          <div className="bg-white px-3 py-2 rounded-lg shadow-lg border border-gray-200 text-sm">
            <div className="flex gap-4 text-gray-600">
              <span>ÎÖ∏Îìú: {filteredNodes.length}</span>
              <span>Ïó£ÏßÄ: {filteredEdges.length}</span>
              {selectedNodes.size > 0 && (
                <span className="text-blue-600 font-medium">
                  ÏÑ†ÌÉùÎê®: {selectedNodes.size}
                </span>
              )}
            </div>
          </div>
        </Panel>
      </ReactFlow>
    </div>
  );
};

/**
 * @brief Î©îÏù∏ Í∑∏ÎûòÌîÑ ÏãúÍ∞ÅÌôî Ïª¥Ìè¨ÎÑåÌä∏ (Provider Ìè¨Ìï®)
 */
const GraphViewer = (props) => {
  // Ìï≠ÏÉÅ ReactFlowÎ•º Î†åÎçîÎßÅÌïòÏó¨ Ï¥àÍ∏∞Ìôî Î¨∏Ï†ú Î∞©ÏßÄ
  return (
    <ReactFlowProvider>
      <GraphViewerInner {...props} />
    </ReactFlowProvider>
  );
};

export default GraphViewer;